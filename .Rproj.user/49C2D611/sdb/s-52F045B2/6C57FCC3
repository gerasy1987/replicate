{
    "collab_server" : "",
    "contents" : "analyses <- function(DV,\n                     treat,\n                     covs = NULL,\n                     heterogenous = NULL,\n                     subset = NULL,\n                     FE = NULL,\n                     cluster = NULL,\n                     IPW = NULL,\n                     data,\n                     model = \"lm\",\n                     status = c(TRUE, TRUE, TRUE)) {\n\n  # required packages\n  requireNamespace(\"plyr\", quietly = TRUE)\n  requireNamespace(\"dplyr\", quietly = TRUE)\n  requireNamespace(\"broom\", quietly = TRUE)\n  requireNamespace(\"Hmisc\", quietly = TRUE)\n  requireNamespace(\"lfe\", quietly = TRUE)\n  requireNamespace(\"multiwayvcov\", quietly = TRUE)\n  requireNamespace(\"lmtest\", quietly = TRUE)\n  # utils::suppressForeignCheck(c(\"printout\", \"estimate\",\"std.error\", \"term\"))\n\n  if (!is.null(FE) & model != \"lm\") stop(\"Function does not support FE for other than OLS models\")\n\n  # generate the formula to use in model.frame to produce nice data frame\n  frame_formula <-\n    stats::as.formula(\n      paste(DV, \"~\",\n            paste(c(treat, covs, FE, cluster, IPW, heterogenous), collapse = \" + \")\n      )\n    )\n\n  if (is.null(heterogenous)) {\n    main_formula <- paste(c(treat, covs), collapse = \" + \")\n  } else {\n    main_formula <-\n      paste(c(treat,\n              paste0(treat, \":\", heterogenous), heterogenous, covs),\n            collapse = \" + \")\n  }\n\n  main_formula <- paste(DV, \"~\", main_formula)\n\n  FE_formula <- ifelse(is.null(FE), 0, paste(FE, collapse = \"+\"))\n  cluster_formula <- ifelse(is.null(cluster), 0, paste(cluster, collapse = \"+\"))\n\n  fit_formula <-\n    stats::as.formula(\n      paste(main_formula,\"|\", FE_formula, \"|\", 0, \"|\", cluster_formula)\n    )\n\n  # generate formula for estimation taking into account possible heterogenous effects\n\n\n  # modify initial dataset to the dataset only with needed information\n  frame_df <- dplyr::filter_(.data = data, .dots = subset)\n  frame_df <-\n    dplyr::filter_(.data = frame_df,\n                   .dots =\n                     paste(paste0(\"!is.na(\",c(treat, DV, FE, cluster, IPW, heterogenous),\")\"),\n                           collapse = \" & \"\n                     ) )\n  frame_df <- stats::model.frame(frame_formula, data = frame_df)\n\n\n  # transform fixed effects to be factors\n  if (length(FE) > 1)\n    frame_df[, FE] <- plyr::colwise(as.factor)(frame_df[, FE])\n\n  if (length(FE) == 1)\n    frame_df[, FE] <- as.factor(frame_df[, FE])\n\n  if (model == \"lm\"){\n\n    if (is.null(IPW)){\n      fit <- lfe::felm(formula = fit_formula,\n                       data = frame_df)\n    } else {\n      fit <- lfe::felm(formula = fit_formula,\n                       data = frame_df,\n                       weights = unlist(frame_df[,IPW]))\n    }\n  } else if (model == \"logit\") {\n    if (is.null(IPW)){\n      fit <-\n        suppressWarnings(\n          stats::glm(formula = stats::as.formula(main_formula),\n                     data = frame_df,\n                     family = binomial(link=\"logit\"))\n        )\n    } else {\n      fit <-\n        suppressWarnings(\n          stats::glm(formula = stats::as.formula(main_formula),\n                     data = frame_df,\n                     weights = unlist(frame_df[,IPW]),\n                     family = binomial(link=\"logit\"))\n        )\n    }\n\n    if (!is.null(cluster)) {\n      fit <- lmtest::coeftest(x = fit,\n                              vcov = multiwayvcov::cluster.vcov(model = fit,\n                                                                cluster = frame_df[,cluster]))\n    }\n  }\n\n  col_names <- c(\"term\", \"estimate\", \"std.error\",\"p.value\")\n\n  if (!is.null(FE)){\n\n    icpt <-\n      unname(\n        plyr::name_rows(\n          lfe::getfe(fit, ef = function(gamma,addnames) absorb(gamma = gamma,\n                                                               addnames = addnames,\n                                                               .FE = frame_df[, FE]),\n                     se = T, bN = 1000, cluster = TRUE)\n        )\n      )\n    icpt <- cbind(icpt[c(5,1,4)],\n                  \"pval\" = 2*stats::pt(unlist(icpt[1])/unlist(icpt[4]),\n                                       df = suppressWarnings(broom::glance(fit)[,\"df\"]),\n                                       lower.tail = FALSE)\n    )\n    colnames(icpt) <- col_names\n    estout <- rbind(icpt, suppressWarnings(broom::tidy(fit)[,col_names]))\n  } else {\n    estout <- broom::tidy(fit)[,col_names]\n    estout[1,1] <- \"intercept\"\n  }\n\n  # subset only the estimated coefficients related to treatment(s) and intercepts\n\n  # generate a nice text output\n  out <-\n    dplyr::mutate(estout,\n                  printout = paste0(fround(estimate, digits = 3),\n                                    \" [\", fround(std.error, digits = 3), \"]\"),\n                  estimate = round(estimate, digits = 3),\n                  std.error = round(std.error, digits = 3),\n                  p.value = round(p.value, digits = 3))\n  out <- dplyr::select(.data = out,\n                       term, estimate, std.error, printout,p.value)\n\n  # return list with adjusted r.sq, estimates and number of observations\n  list(estimates = out,\n       stat = c(\n         adj.r.squared = ifelse(model == \"lm\", fround(broom::glance(fit)$adj.r.squared,digits = 3), NA),\n         n_obs = fround(nrow(frame_df), digits = 0)\n       ),\n       model_spec = c(HETEROGENOUS = ifelse(!is.null(heterogenous), paste(heterogenous, collapse = \" \"), NA),\n                      FE = ifelse(!is.null(FE), paste(FE, collapse = \" \"), \"no\"),\n                      CLUSTER = ifelse(!is.null(cluster), paste(cluster, collapse = \" \"), \"no\"),\n                      IPW = ifelse(!is.null(IPW), paste(IPW, collapse = \" \"), \"no\")),\n       model_status = c(R = status[1],\n                        S = status[2],\n                        P = status[3])\n  )\n}\n\n\n\nabsorb <- function(gamma, addnames, .FE){\n  ws <- table(.FE, useNA = 'no')\n  icpt <- wtd_mean(gamma, weights = ws)  # first level of f1\n  result <- c(icpt)\n  if(addnames) {\n    names(result) <- \"intercept\"\n    attr(result, \"extra\") <- list(fe = factor(\"icpt\"),\n                                  obs = factor(length(.FE)))\n  }\n  result\n}\n\n\n\nfround <- function (x, digits) {\n  format(round(x, digits), nsmall = digits)\n}\n\n\n\nmgsub <- function(pattern, replacement, x, ...) {\n  if (length(pattern) != length(replacement)) {\n    stop(\"pattern and replacement do not have the same length.\")\n  }\n  result <- x\n  for (i in 1:length(pattern)) {\n    result <- gsub(pattern[i], replacement[i], result, ...)\n  }\n  result\n}\n\n\npfround <- function (x, digits) {\n  print(fround(x, digits), quote = FALSE)\n}\n\nset_seed <- function(.seed = 12345, .parallel = FALSE) {\n  # required packages\n  requireNamespace(\"mosaic\", quietly = TRUE)\n\n  if (.parallel) mosaic::set.rseed(seed = .seed)\n  else set.seed(seed = .seed)\n}\n\nwtd_mean <- function (x, weights = NULL, normwt = \"ignored\", na.rm = TRUE) {\n  if (!length(weights))\n    return(mean(x, na.rm = na.rm))\n  if (na.rm) {\n    s <- !is.na(x + weights)\n    x <- x[s]\n    weights <- weights[s]\n  }\n  return(sum(weights * x)/sum(weights))\n}\n",
    "created" : 1470263732711.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "509119191",
    "id" : "6C57FCC3",
    "lastKnownWriteTime" : 1470352324,
    "last_content_update" : 1470352324298,
    "path" : "~/Google Drive/7 - Projects/Replicate/replication_function.R",
    "project_path" : "replication_function.R",
    "properties" : {
        "chunk_rendered_width" : "650",
        "tempName" : "Untitled2"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}